unit AutoNameGenerator;

{$MODE Delphi}

{+------------------------------------------------------------------------+
 | AutoREALM.   Copyright (c) 2000, Andrew J. Gryc.                       |
 |                                                                        |
 | This program is free software; you can redistribute it and/or modify   |
 | it under the terms of the GNU General Public License as published by   |
 | the Free Software Foundation; either version 2 of the License, or (at  |
 | your option) any later version.                                        |
 |                                                                        |
 | This program is distributed in the hope that it will be useful, but    |
 | WITHOUT ANY WARRANTY; without even the implied warranty of             |
 | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU      |
 | General Public License for more details.                               |
 |                                                                        |
 | For a copy of the GNU General Public License, write to the Free        |
 | Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA     |
 | 02111-1307, USA.                                                       |
 +------------------------------------------------------------------------+}


interface

function OpenRuleFile(dir, name:string):boolean;
procedure CloseRuleFile;
function GenerateRule:string;
procedure ShowProbabilities(b:boolean);
procedure ShowErrorBox(b:boolean);
function GetErrorString:string;

implementation

(*+------------------------------------------------------------------------+
   AutoNAME: A fantasy name generator for use with AutoREALM

   There are two types of rules used in the .rul files read by AutoNAME.
   They are production rules (=>) and replacement rules (==).  Comments
   are started by //, and continue to the end of a line.

   Production rules govern generation of strings, are randomly selected
   (using either an equal percentage, or one supplied by the user), and
   follow a context free grammar.  Although all non-terminals are by
   convention upper-case, any series of consecutive alpha characters can
   be used as a non-terminal.  Any non-alpha characters can be used to
   separate a non-terminal.

   The first non-terminal in the file is considered the primary rule,
   and is used to start each generated name.  Any line that is missing
   a left hand side or arrow uses the last valid non-terminal.

   Production rules may have a percentage or weight to the left of the
   arrow.  All rules that are part of a non-terminal that do not have
   a specified probability divide the remaining probability equally among
   themselves. E.g.
       RULE [%25] => One quarter the time
            [%50] => One-half the time
            [.10] => Ten percent of the time
                  => Remaining percent split between this rule
                  => and this one, for 7.5% each.

   The following special symbols are used in production rules:
     ""      Quotes the rule contents.
               E.g. RULE => "His'n hers"

     {}      Can be used to separates two adjacent non-terminals.
               E.g. RULE => {FIRST}{LAST}
             Also may contain "roll" expressions, like 3d6, etc. for
             rolling dice.  Rolls must be of the form
             {<NUMDICE>d<DIEFACES>[Max|Min<INTEGER>][+|-<INTEGER>]}
               E.g. RULE => {3d6}{4d4+2}{5d6Max3}

     []      Contents of brackets are inserted 50% of the time.
             E.g. RULE => This [and] that

     <>      Meaning accumulator: used to accumulate a descriptive
             buffer.  Any text inside the brackets is added to a buffer
             that starts as empty at the beginning of the rule.  Empty
             brackets will dump the contents of the buffer into the
             rule and reset the buffer.
             E.g.    TOPRULE => RULE means <>  // Show word and its meaning
                     RULE => Arg <Anvil>       // Arg means "Anvil"
                          => Blarg <Foe>       // Blarg means "Foe"

   Replacement rules are applied after all production rules are finished.
   Replacement rules occur in order, replace until no longer applicable,
   do not require any particular strings on either left or right hand
   sides, and are always applied (i.e. not random).
   They are used for correcting problems generated by pasting adjacent
   text that would be very difficult to fix by altering the rules themselves.

   E.g.
         //
         // Replacement rules: fix up any bad English
         //
         The The==The
         s's==s'
         Mummys==Mummies

 +------------------------------------------------------------------------+*)

uses Classes, Forms, LCLIntf, LCLType, LMessages, Messages, Dialogs, SysUtils;

type PRule = ^Rule;
     Rule = record
       contents:string;
       probability:single;
       next:PRule;
     end;

     PProduction = ^Production;
     Production = record
       name:string;
       rules:PRule;
       next:PProduction;
     end;

     PReplacement = ^Replacement;
     Replacement = record
       left,right:string;
       next:PReplacement;
     end;

const RecursionMax = 50;                // Hope it never gets this deep!
      ReplacementMax = 20;              // Just in case they add bad rules like
                                        // A==AA which will recurse forever.
resourcestring
  res_autonamegen_noprob =  'Probability is missing ]';
  res_autonamegen_brace =   'Unmatched {} braces';
  res_autonamegen_bracket = 'Unmatched [] brackets';
  res_autonamegen_angle =   'Unmatched <> brackets';
  res_autonamegen_quote =   'Unmatched "" quotes';
  res_autonamegen_unknown = 'Probability ends with unknown character';
  res_autonamegen_label_noprod = 'Found => with no prior production label (left hand side)';
  res_autonamegen_99 =      'probability totals less than 100%';    // 1 space is added before
  res_autonamegen_101 =     'probability totals greater than 100%'; //    "     "
  res_autonamegen_notexist= 'does not exist.';                      //    "     "
  res_autonamegen_toomuch = 'contained too many errors; parsing aborted.';//    "


var FirstProduction:PProduction;        // First in the list
    PrimaryProduction:PProduction;      // The first in the file: we generate this top rule
    CurrentProduction:PProduction;      // Rule being added to implicitly
    PrintProbabilities:boolean;         // Shows probabilities of each option
    fShowErrorBox:boolean;              // Automatically launch error box
    RecursionDepth:integer;             // Prevent stack overflows
    FirstReplacement:PReplacement;      // First replacement
    LastReplacement:PReplacement;       // Last replacement
    ErrorString:string;                 // String for accumulated errors
    MeaningString:string;               // String for an accumulated meaning

function RandomRule(prod:PProduction):string; forward;
function ReadRules(dir,name:string):boolean;      forward;

function FindProduction(s:string):PProduction;
var pr:PProduction;
begin
  pr:=FirstProduction;

  while (pr<>nil) do begin
    if (s=pr^.name) then begin
      Result:=pr; exit;
      end;
    pr:=pr^.next;
    end;

  Result:=nil;
end;


//-----------------------------------------------------------------------
// Given a string that may contain a die roll, figure out if it does or
// not, and roll it if necessary.
//    <NUMDICE>d<DIEFACES>[Max|Min<INTEGER>][+|-<INTEGER>]
//-----------------------------------------------------------------------
function ComputeRoll(s:string):string;
const MAX_DICE=100;
var num_dice:integer;
    die_faces:integer;
    addition:integer;
    domin,domax:boolean;
    eliminatedies:integer;
    i,err,sum:integer;
    dice:array[0..MAX_DICE] of integer;

   procedure QuickSort(L, R: Integer);
   var
     I, J: Integer;
     P: integer;

     procedure Exchange(var l,r:integer);
     var t:integer;
     begin
       t:=l; l:=r; r:=t;
     end;

   begin
     repeat
       I := L;
       J := R;
       P := dice[(L + R) shr 1];
       repeat
         while dice[i]<P do Inc(I);
         while dice[j]>P do Dec(J);
         if I <= J then
         begin
           Exchange(dice[I],dice[J]);
           Inc(I);
           Dec(J);
         end;
       until I > J;
       if L < J then QuickSort(L, J);
       L := I;
     until I >= R;
   end;

begin
  Result:=s;
  if (length(s)=0) then exit;

  // Do we have a non-zero number followed by a 'd'?
  Val(s,num_dice,err);
  if (num_dice=0) or (err=0) or (s[err]<>'d') then exit;
  if (num_dice>MAX_DICE) then exit;

  delete(s,1,err);          // Remove "<NUMDICE>d"

  addition:=0;
  domin:=false;
  domax:=false;
  eliminatedies:=0;

  // What is the number following the d?
  // If it's a percentile (3d00) then check specially, cause that'll come
  // out as zero.
  if (copy(s,1,2)='00') then begin
    die_faces := 100;
    delete(s,1,2);
    end
  else begin
    val(s,die_faces,err);
    if (die_faces=0) then exit;
    if (err<>0) then delete(s,1,err-1);     // Delete number die faces.
    end;

  // Look for a min or max or +/- past the number of die-faces
  if (length(s)<>0) then begin
    if (Uppercase(copy(s,1,3))='MAX') then begin
      delete(s,1,3);
      domax:=true;
      end;
    if (Uppercase(copy(s,1,3))='MIN') then begin
      delete(s,1,3);
      domin:=true;
      end;
    if domin or domax then begin
      val(s,eliminatedies,err);
      if (eliminatedies<>0) then eliminatedies:=num_dice-eliminatedies;
      if (err=0) then s:='' else delete(s,1,err-1);
      end;

    if (copy(s,1,1)='+') or (copy(s,1,1)='-') then begin
      val(s,addition,err);
      if (err<>0) then delete(s,1,err-1);
      end;
    end;

  for i:=0 to num_dice-1 do dice[i] := Random(die_faces)+1;

  sum:=0;

  if domax then begin
    QuickSort(0,num_dice-1);
    for i:=0 to num_dice-eliminatedies-1 do sum:=sum+dice[i+eliminatedies];
    end
  else if domin then begin
    QuickSort(0,num_dice-1);
    for i:=0 to num_dice-eliminatedies-1 do sum:=sum+dice[i];
    end
  else begin
    for i:=0 to num_dice-1 do sum:=sum+dice[i];
    end;

  Result:=IntToStr(sum+addition);
end;

function AddProduction(s:string):PProduction;
var pr:PProduction;
begin
  pr:=FindProduction(s);

  if (pr<>nil) then
    Result:=pr
  else begin
    New(Result);
    Result^.next:=FirstProduction;
    Result^.name:=s;
    Result^.rules:=nil;
    FirstProduction := Result;
    if (PrimaryProduction=nil) then PrimaryProduction := Result;
    end;
end;


function AddReplacement(left,right:string):PReplacement;
begin
  New(Result);
  Result^.left:=left;
  Result^.right:=right;
  Result^.next := nil;
  if (LastReplacement=nil) then
    FirstReplacement := Result
  else
    LastReplacement^.next := Result;

  LastReplacement:=Result;
end;

function DoReplacements(s:string):string;
var count:integer;
    rep:PReplacement;
    p:integer;
begin
  rep:=FirstReplacement;
  while (rep<>nil) do begin
    count:=0;
    repeat
      p:=pos(rep^.left,s);
      if (p<>0) then begin
        delete(s,p,length(rep^.left));
        insert(rep^.right,s,p);
        inc(count);
        end;
    until (p=0) or (count>ReplacementMax);

    rep:=rep^.next;
    end;

  Result:=s;
end;

function AddRule(prod:PProduction; s:string; prob:single):PRule;
begin
  New(Result);
  Result^.contents:=s;
  Result^.probability:=prob;
  Result^.next := prod^.rules;
  prod^.rules := Result;
end;


function GetToken(var s:string):string;
var len:integer;
begin
  len:=0;
  while (len<=length(s)) and (s[len+1] in ['A'..'Z','a'..'z']) do inc(len);

  // If not an alphanumeric word, then get the next char solo
  if (len=0) then len:=1;

  Result:=copy(s,1,len);
  delete(s,1,len);
end;


function GetUntil(var s:string; ch:char; var found:boolean):string;
var len:integer;
begin
  found:=false;
  len:=0;
  while (len<=length(s)) and (s[len+1]<>ch) do inc(len);

  Result:=copy(s,1,len);
  if (len<=length(s)) and (s[len+1]=ch) then begin
    inc(len);
    found:=true;
    end;
  delete(s,1,len);
end;

function GetUntilCounted(var s:string; starter,stopper:char; var found:boolean):string;
var len:integer;
    pair:integer;
begin
  found:=false;
  len:=1;
  pair:=1;
  while (len<=length(s)) and (pair>0) do begin
    if (s[len]=starter) then inc(pair);
    if (s[len]=stopper) then dec(pair);
    inc(len);
    end;

  if (pair=0) then begin
    Result:=copy(s,1,len-2);
    delete(s,1,len-1);
    found:=true;
    end;
end;

function GetName(s:string):string;
var pr:PProduction;
begin
  pr:=FindProduction(s);
  if (pr=nil) then
    Result:=s
  else
    Result:=RandomRule(pr);
end;

function GetRule(contents:string; ParseOnly:boolean):string;
var tok:string;
    found:boolean;
begin
  Result:='';
  if (contents='') then exit;

  if (RecursionDepth=RecursionMax) then exit;

  inc(RecursionDepth);

  repeat
    tok:=GetToken(contents);
    if (length(tok)=1) then begin
      case tok[1] of
        '{': begin
               tok:=GetUntil(contents,'}',found);
               if (not found) then begin
                 if ParseOnly then Result:=res_autonamegen_brace;
                 exit;
                 end;
               if not ParseOnly then begin
                 tok:=ComputeRoll(tok);                   // Roll if necessary
                 Result:=Result+GetName(tok);             // Get {NAME}
                 end;
             end;
        '[': begin
               tok:=GetUntilCounted(contents,'[',']',found);
               if (not found) then begin
                 if ParseOnly then Result:=res_autonamegen_bracket;
                 exit;
                 end;
               // 50% chance of doing the contents of the brackets
               if (not ParseOnly) and (Random >= 0.5) then begin
                 Result:=Result+GetRule(tok,ParseOnly); // Parse as a new rule
                 end;
             end;
        '<': begin
               tok:=GetUntil(contents,'>',found);
               if (not found) then begin
                 if ParseOnly then Result:=res_autonamegen_angle;
                 exit;
                 end;
               if not ParseOnly then begin
                 if (tok<>'') then begin
                    MeaningString:=MeaningString+tok;
                    end
                 else begin
                    Result:=Result+MeaningString;
                    MeaningString:='';
                    end;
                 end;
             end;
        '"': begin
               tok:=GetUntil(contents,'"',found);
               if (not found) then begin
                 if ParseOnly then Result:=res_autonamegen_quote;
                 exit;
                 end;
               Result:=Result+tok;      // Use the token literaly
             end;
        else // Not a recognized one-character token
          if not ParseOnly then begin
            Result:=Result+GetName(tok);
            end;
        end;
      end
    else begin
      //
      // Any tokens longer than one character
      //
      if not ParseOnly then begin
        Result:=Result+GetName(tok);
        end;
      end;

  until (length(contents)=0);

  dec(RecursionDepth);

  if ParseOnly then Result:='';             // Don't care about
end;


function RandomRule(prod:PProduction):string;
var p:single;
    rul:PRule;
begin
  p:=Random;
  rul:=prod^.rules;

  while (rul<>nil) do begin
    p:= p - rul^.probability;
    if (p<=0.0) then begin
      Result:=GetRule(rul^.contents, false);
      exit;
      end;

    rul:=rul^.next;
    end;

  // If we managed to fall through this loop because of some floating
  // point round-off, just use the first rule.
  Result:=GetRule(prod^.rules^.contents, false);
end;


function GenerateRule:string;
begin
  // Start with empty meaning (this isn't philisophical :-)
  MeaningString := '';

  if PrimaryProduction=nil then
    Result:=''
  else
    Result:=DoReplacements(RandomRule(PrimaryProduction));
end;


function RuleParse(dir,filename:string; linenumber:integer; s:string):boolean;
const IncludeStr='#include';
var rp:integer;
    left,right:string;
    probability:single;

  procedure Error(s:string);
  begin
    ErrorString:=ErrorString+filename+'('+IntToStr(linenumber)+') : '+s+#13#10;
  end;

  procedure RemoveComments(var s:string);
  var cp:integer;
  begin
     cp:=pos('//',s);
     if (cp<>0) then delete(s,cp,length(s));
  end;

  function RemoveProbability(var s:string):single;
  var lp,prob,err:integer;
      prs:string;
  begin
    Result:=0.0;

    lp:=pos('[',left);
    if (lp<>0) then begin
      prs:=copy(s,lp+1,length(s));
      val(prs,prob,err);                    // Get the first err char.

      if (prob<>0) and (err=0) then begin     // Require some type of terminator
        Error(res_autonamegen_noprob); exit;
        end;

      if (prs[err]=']') then begin
        prs:=copy(prs,1,err-1);
        val(prs,Result,err);
        end
      else if (prs[err]='%') then begin
        prs:=copy(prs,1,err-1);
        val(prs,Result,err);
        Result:=Result*0.01;                // Percentage is 1/100th.
        end
      else begin
        Error(res_autonamegen_unknown); exit;
        end;

      s:=Trim(copy(s,1,lp-1));              // Remove the probability
      end;
  end;

  function FixReplacementString(s:string):string;
  begin
    s:=Trim(s);   // Remove spaces
    if (copy(s,1,1)='"') and (copy(s,length(s),1)='"') then begin
      s:=copy(s,2,length(s)-2);
    end;
    Result:=s;
  end;

begin
  Result:=false;
  RemoveComments(s);
  s:=Trim(s);

  // Deal with blank lines (and only-comment lines) first
  if (s='') then begin          // Blank lines are NOPs
    Result:=true; exit;
    end;

  // Deal with included files
  if (copy(s,1,length(IncludeStr))=IncludeStr) then begin
    s:=Trim(copy(s,length(IncludeStr)+1,length(s)));
    Result:=ReadRules(dir,s);
    exit;
    end;

  // Is this a replacement operator?
  rp:=pos('==',s);
  if (rp<>0) then begin
    left:=FixReplacementString(copy(s,1,rp-1));
    right:=FixReplacementString(copy(s,rp+2,length(s)));
    AddReplacement(left,right);
    Result:=true; 
    exit;
    end;

  //
  // Split the line into a LHS and RHS
  //
  rp:=pos('=>',s);              // Find the production rule operator
  if (rp=0) then begin
    left:='';               // With no => operator, make the whole thing
    right:=s;               // the right hand side
    end
  else begin
    left := Trim(copy(s,1,rp-1));
    right:= Trim(copy(s,rp+2,length(s)));
    end;

  // Remove probability if present
  probability := RemoveProbability(left);

  if (left<>'') then CurrentProduction:=AddProduction(left);

  // Must have a production label (implicit or explicit)
  if (CurrentProduction=nil) then begin       // No rule name present
    Error(res_autonamegen_label_noprod); exit;
    end;

  // If the right hand side is empty, don't add a rule for it.
  if (right='') then begin
    Result:=true; exit;
    end;

  // Make sure the rule doesn't contain syntax errors
  if (GetRule(right,true)<>'') then begin
    Error(GetRule(right,true)); exit;
    end;

  AddRule(CurrentProduction, right, probability);

  Result:=true;
end;


function ProbabilityStr(f:single):string;
begin
  Str((f*100.0):7:4,Result);
  Result:=TrimLeft(Result);
  while (Result[length(Result)]='0') do delete(Result,length(Result),1);

  if (Result[length(Result)]='.') then delete(Result,length(Result),1);
end;


function NormalizeProbabilities:boolean;
var prod:PProduction;

  function NormalizeProduction(prod:PProduction):boolean;
  var rul:PRule;
      non_assigned:integer;
      totalprob:single;
      setprob:single;
  begin
    Result:=false;
    // take a first pass to count rules that have no assigned probability
    non_assigned:=0;
    totalprob:=0.0;

    rul:=prod^.rules;
    while (rul<>nil) do begin
      if (rul^.probability=0.0) then
        inc(non_assigned)
      else
        totalprob := totalprob + rul^.probability;

      rul:=rul^.next;
      end;

    if (totalprob>1.0) then begin
      ErrorString:=ErrorString+prod^.name+' '+res_autonamegen_101+#13#10;
      exit;
      end;

    if (non_assigned=0) and (totalprob<1.0) then begin
      ErrorString:=ErrorString+prod^.name+' '+res_autonamegen_99+#13#10;
      exit;
      end;

    if (non_assigned=0) then begin
      Result := true;
      exit;
      end;

    // Divy up the probability equally among those left.
    setprob := (1.0-totalprob)/non_assigned;
    rul:=prod^.rules;
    while (rul<>nil) do begin
      if (rul^.probability=0.0) then rul^.probability:=setprob;

      if PrintProbabilities then begin
        if (prod=PrimaryProduction) then ErrorString:=ErrorString+'*';

        ErrorString:=ErrorString+prod^.name+'['+ProbabilityStr(rul^.probability)+'%]=>'+rul^.contents+#13#10;
        end;

      rul:=rul^.next;
      end;

    Result:=true;
  end;

begin
  Result:=false;
  prod:=FirstProduction;
  while (prod<>nil) do begin
    if not NormalizeProduction(prod) then exit;
    prod:=prod^.next;
    end;
  Result:=true;
end;

function ReadRules(dir,name:string):boolean;
var f:text;
    s:string;
    errorcount:integer;
    linenumber:integer;
begin
  if (pos('.',name)=0) then name:=name+'.rul';

  AssignFile(f,dir+name);
  {$I-}
  Reset(f);
  {$I+}
  if (IOResult<>0) then begin
    ErrorString:=ErrorString+dir+name+' '+res_autonamegen_notexist+#13#10;
    Result:=false;
    exit;
    end;

  RecursionDepth := 0;
  errorcount:=0;
  linenumber:=0;

  while (not EOF(f)) and (errorcount<50) do begin
    readln(f,s);
    inc(linenumber);
    if not RuleParse(dir,name,linenumber,s) then inc(errorcount);
    end;

  if (not EOF(f)) then begin
    ErrorString:=ErrorString+name+' '+res_autonamegen_toomuch+#13#10;
    end;

  CloseFile(f);

  Result := (errorcount=0);
end;

procedure ShowProbabilities(b:boolean);
begin
  PrintProbabilities:=b;
end;

procedure ShowErrorBox(b:boolean);
begin
  fShowErrorBox:=b;
end;

function GetErrorString:string;
begin
  GetErrorString:=ErrorString;
end;

function OpenRuleFile(dir, name:string):boolean;
begin
  CloseRuleFile;
  Randomize;
  FirstProduction:=nil;
  CurrentProduction:=nil;
  PrimaryProduction:=nil;
  ErrorString:='';
  PrintProbabilities:=false;
  fShowErrorBox:=true;

  if ReadRules(dir, name) and NormalizeProbabilities then begin
    OpenRuleFile := true;
    end
  else begin
    OpenRuleFile := false;

    if fShowErrorBox then ShowMessage(ErrorString);
    end;
end;

procedure CloseRuleFile;
var prod,nextprod:PProduction;
    rule,nextrule:PRule;
    rep,nextrep:PReplacement;
begin
  prod:=FirstProduction;
  while (prod<>nil) do begin
    rule:=prod.rules;
    while (rule<>nil) do begin
      nextrule:=rule.next;
      Dispose(rule);
      rule:=nextrule;
      end;

    nextprod:=prod.next;
    Dispose(prod);
    prod:=nextprod;
    end;

  rep:=FirstReplacement;
  while (rep<>nil) do begin
    nextrep:=rep.next;
    Dispose(rep);
    rep:=nextrep;
    end;

  FirstProduction:=nil;
  PrimaryProduction:=nil;
  CurrentProduction:=nil;
  RecursionDepth:=0;
  FirstReplacement:=nil;
  LastReplacement:=nil;
end;

end.
